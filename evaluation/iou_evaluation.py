# -*- coding: utf-8 -*-
"""Results_IDL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FoGSzs7dL5NkrFessAZo96s_QC5l8UEa
"""

import pickle

with open('global_val_loss.pkl', 'rb') as f:
  x = pickle.load(f)
print(x[-1])

import numpy as np

ground_truth = np.load('ground_truth.npy')
predicted = np.load('predicted.npy')

ground_truth_small = ground_truth[:, :, [0, 1, 2, 3, 4, 8, 9, 10, 11]]
predicted_small = predicted[:, :, [0, 1, 2, 3, 4, 8, 9, 10, 11]]

from sklearn.metrics import precision_score, accuracy_score, average_precision_score
average_precision_score(ground_truth_small, predicted_small)
#accuracy_score(ground_truth_small, predicted_small)#, precision_score(ground_truth_small, predicted_small)

bbox_pred = predicted_small[:, :, 1:5]

bbox_ground = ground_truth_small[:, :, 1:5]

predicted_small.shape

import numpy as np

def calculate_map(gt, pred):
    #sorted_indices = np.argsort(pred)[::-1]
    #print(sorted_indices)
    #gt_sorted = gt[sorted_indices]
    #tp = np.cumsum(gt_sorted)
    #fp = np.cumsum(1 - gt_sorted)
    tp = np.cumsum(gt)
    fp = np.cumsum(1 - gt)
    recall = tp / np.sum(gt)
    precision = tp / (tp + fp)
    ap = np.trapz(precision, recall)
    return ap

def calculate_mean_average_precision(gt_array, pred_array):
    ap_values = []
    for i in range(gt_array.shape[0]):
        ap = calculate_map(gt_array[i], pred_array[i])
        ap_values.append(ap)
    return np.mean(ap_values)

print(ground_truth_small.shape)
print(predicted_small.shape)
print(calculate_mean_average_precision(ground_truth_small, predicted_small))
print(calculate_mean_average_precision(bbox_ground, bbox_pred))

def calculate_ap(gt, pred):
    sorted_indices = np.argsort(pred)[::-1]
    gt_sorted = gt[sorted_indices]
    tp = np.cumsum(gt_sorted)
    fp = np.cumsum(1 - gt_sorted)
    recall = tp / np.sum(gt)
    precision = tp / (tp + fp)
    ap = np.trapz(precision, recall)
    return ap

calculate_mean_average_precision(ground_truth_small, predicted_small)

import numpy as np

def cosine_similarity(a, b):
    dot_product = np.dot(a, b)
    norm_a = np.linalg.norm(a)
    norm_b = np.linalg.norm(b)
    return dot_product / (norm_a * norm_b)

def calculate_iou_3d(box1, box2):
    """
    Calculate the IOU between two 3D bounding boxes.

    Args:
        box1: a tuple of (x1, y1, z1, l1, w1, h1, r1) representing the coordinates and dimensions of box 1
        box2: a tuple of (x2, y2, z2, l2, w2, h2, r2) representing the coordinates and dimensions of box 2

    Returns:
        The IOU between box1 and box2.
    """
    # Calculate the coordinates of the intersection box
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    z1 = max(box1[2], box2[2])
    x2 = min(box1[0] + box1[3], box2[0] + box2[3])
    y2 = min(box1[1] + box1[4], box2[1] + box2[4])
    z2 = min(box1[2] + box1[5], box2[2] + box2[5])

    # Calculate the volume of the intersection box
    inter_vol = max(0, x2 - x1) * max(0, y2 - y1) * max(0, z2 - z1)

    # Calculate the volume of the union box
    box1_vol = box1[3] * box1[4] * box1[5]
    box2_vol = box2[3] * box2[4] * box2[5]
    union_vol = box1_vol + box2_vol - inter_vol

    # Calculate the IOU
    iou = inter_vol / union_vol

    return iou

ground_truth[1, 1, :]

total = 0
correct = 0
incorrect = 0
iou_thresh = 0.3
for i in range(ground_truth.shape[0]):
  for t in range(ground_truth.shape[1]):
    g = list(ground_truth[i, t, 5:])
    p = list(predicted[i, t, 5:])
    g_new = [0 for i in range(7)]
    p_new = [0 for i in range(7)]
    mapping = {0:3, 1:4, 2: 5, 3:0, 4: 1, 5:2, 6:6}
    for i in range(7):
      g_new[i] = g[mapping[i]]
      p_new[i] = p[mapping[i]]
    iou = calculate_iou_3d(g_new, p_new)
    if iou > iou_thresh:
      correct += 1
    else:
      incorrect += 1
    total += 1
    #calculate_iou_3d(g_new, p_new)
print("IOU Threshold is {0}".format(iou_thresh))
acc = (correct/ total) * 100
print("Accuracy is {0}".format(str(acc)))

def iou_2d(box1, box2):
    """
    Calculate the Intersection over Union (IoU) of two 2D bounding boxes.

    Args:
        box1: list of 4 numbers [x1, y1, x2, y2] representing the coordinates of the top-left and
              bottom-right corners of the first box.
        box2: list of 4 numbers [x1, y1, x2, y2] representing the coordinates of the top-left and
              bottom-right corners of the second box.

    Returns:
        float value representing the IoU of the two boxes.
    """
    # calculate area of the boxes and the intersection area
    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])
    intersection_area = max(0, x2 - x1) * max(0, y2 - y1)

    # calculate union area and return IoU
    union_area = area1 + area2 - intersection_area
    iou = intersection_area / union_area if union_area != 0 else 0
    return iou

total = 0
correct = 0
incorrect = 0
iou_thresh = 0.7
for i in range(ground_truth.shape[0]):
  for t in range(ground_truth.shape[1]):
    g = list(ground_truth[i, t, 1:5])
    p = list(predicted[i, t, 1:5])
    #g_new = [0 for i in range(4)]
    #p_new = [0 for i in range(4)]
    #mapping = {0:0, 1:3, 2: 1, 3:3}
    #for i in range(4):
    #  g_new[i] = g[mapping[i]]
    #  p_new[i] = p[mapping[i]]
    g_new = g
    p_new = p
    iou = iou_2d(g_new, p_new)
    #print(iou)
    #break
    if iou > iou_thresh:
      correct += 1
    else:
      incorrect += 1
    total += 1
    #calculate_iou_3d(g_new, p_new)
print("IOU Threshold is {0}".format(iou_thresh))
acc = (correct/ total) * 100
print("Accuracy is {0}".format(str(acc)))

